import os
import requests
from typing import List, Optional
from bs4 import BeautifulSoup
import hashlib
import sqlite3
from datetime import datetime
import jsonlines
import json
import shutil

def get_md5(file_name):
    """
    Getting MD5 of each individual json file
    """
    hash_md5 = hashlib.md5()
    with open(file_name, 'rb') as file:
        for chunk in iter(lambda: file.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()

def download_json_files() -> List[str]:
    """
    Download and count all individual json files
    
    """
    
    files_list = []
    url = "https://tools.clariah.nl/files/"
    save_directory = "tools_metadata"

    if not os.path.exists(save_directory):
        os.makedirs(save_directory)

    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')
    links = soup.find_all('a')

    count = 0

    for link in links:
        href = link.get('href')
        if href.endswith('.codemeta.json'):
            file_url = url + href
            print(f"Downloading {file_url}")
            response = requests.get(file_url)
            file_name = os.path.join(save_directory, href)
            files_list.append(file_name)
            with open(file_name, 'wb') as file:
                file.write(response.content)
            count += 1

    print(f"Downloaded all the tools metadata! Total JSON files: {count}")
    return files_list


def get_files(folder_name: str) -> Optional[List[str]]:
    """
    get all the files in the folder
    """
    if not os.path.exists(folder_name):
        return None
    files_list = os.listdir(folder_name)
    return files_list


def create_db_table(conn: sqlite3.Connection, table_name: str = "tools_metadata") -> None:
    """
    create a table in the database
    """
    c = conn.cursor()
    c.execute(f"CREATE TABLE {table_name} (file_name text, md5 text, timestamp text DEFAULT CURRENT_TIMESTAMP)")
    conn.commit()


def db_table_exists(conn: sqlite3.Connection, table_name: str = "tools_metadata") -> bool:
    """
    check if the table exists in the database
    """
    c = conn.cursor()
    c.execute(f"SELECT count(name) FROM sqlite_master WHERE type='table' AND name='{table_name}'")
    if c.fetchone()[0] == 1:
        return True
    return False


def init_check_db(db_file_name: str, table_name: str) -> Optional[sqlite3.Connection]:
    """
    check if the database exists, if not create one
    """
    conn = sqlite3.connect(db_file_name)
    
    # check if table exists
    if not db_table_exists(conn, table_name):
        print(f"Table {table_name} does not exis, creating!")
        create_db_table(conn, table_name)

    return conn


if __name__ == '__main__':
    """
    main function
    """
    # init db and check if the table exists
    conn = init_check_db(db_file_name="tools_metadata.db", table_name="tools_metadata")
    if conn is None:
        print("Error in creating the database connection!")
        exit(1)
    
    # create a cursor
    c = conn.cursor()

    # get all the json files and convert them into one jsonlines file named codemeta.jsonl
    docfiles = download_json_files()

    with jsonlines.open("codemeta.jsonl", mode="w") as writer:
        # simulating a change in codemeta.jsonl (remove #)
        # writer.write({"INEOtool_field": "INEOtool_value"})

        for file in docfiles:
            with open(file, 'r') as json_file:
                data = json.load(json_file)
                writer.write(data)

    # Calculate MD5 hash for codemeta.jsonl
    codemeta_hash = get_md5('codemeta.jsonl')
    print(f"codemeta.jsonl md5: {codemeta_hash}")

    # Check if the hash of codemeta.jsonl has changed since the last timestamp
    c.execute("SELECT md5 FROM tools_metadata WHERE file_name='codemeta.jsonl' ORDER BY timestamp DESC LIMIT 1")
    md5_timestamp = c.fetchone()

    if md5_timestamp is not None and md5_timestamp[0] == codemeta_hash:
        print("codemeta.jsonl hash has not changed. Skipping individual file hashes calculation and back-up.")
    else:
        # Retrieve the latest timestamp from the database
        c.execute("SELECT timestamp FROM tools_metadata ORDER BY timestamp DESC LIMIT 1")
        latest_timestamp = c.fetchone()

        if latest_timestamp is not None:
            latest_timestamp = datetime.strptime(latest_timestamp[0], "%Y-%m-%d %H:%M:%S")
        else:
            latest_timestamp = datetime.now()

        # Create a directory to back-up tools_metadata (because the hash of codemeta.jsonl has changed)
        backup_directory = f"tools_metadata_backup_{latest_timestamp.strftime('%Y%m%d%H%M%S')}"

        if not os.path.exists(backup_directory):
            os.makedirs(backup_directory)
        else:
            print(f"Backup directory '{backup_directory}' already exists. Skipping back-up.")

        # Copy all files from the original directory to the backup directory
        files = get_files("tools_metadata")
        if files is None:
            print("No files found in the directory")
            exit(0)

        for file in files:
            source_path = os.path.join('tools_metadata', file)
            destination_path = os.path.join(backup_directory, file)
            shutil.copyfile(source_path, destination_path)

        # Compute MD5 hash for each json file and store them in the database
        files = get_files("tools_metadata")

        for file in files:
            timestamp = datetime.now()
            md5_hash = get_md5(os.path.join('tools_metadata', file))
            print(f"file: {file} md5: {md5_hash}")
            # Store the md5 in the database
            c.execute("INSERT INTO tools_metadata VALUES (?, ?, ?)", (file, md5_hash, str(timestamp.strftime("%Y-%m-%d %H:%M:%S"))))

    # Update the timestamp for codemeta.jsonl in the database
    codemeta_timestamp = datetime.now() 
    c.execute("INSERT INTO tools_metadata VALUES (?, ?, ?)", ('codemeta.jsonl', codemeta_hash, str(codemeta_timestamp.strftime("%Y-%m-%d %H:%M:%S"))))

    conn.commit()

    # RumbleDB query (rating >= 3 stars)
    rumble_query = """
        for $i in json-file("codemeta.jsonl",10)
        where $i.review.reviewRating ge 3
        return $i.identifier
        """
    with open("rumble_query.rq", "w") as file:
        file.write(rumble_query)
